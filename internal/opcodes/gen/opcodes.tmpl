package opcodes

import (
	"errors"
	"fmt"
	"io"
	"unicode/utf8"
	"strconv"

	"github.com/vsinha/vm/internal/vm"
)

// ErrNoOpCode is a little alias for the error message returned below
var ErrNoOpCode = errors.New("no opcode with that address exists")

// TODO this has problems because many of the opcodes have the same mnemonic,
// so we have to think about how to disambiguate them or if we even want to
type Op int

type OpCode interface {
	Execute(*vm.VM) 
	String() string
	Write(io.Writer) (int, error)
}

// Fake converting UTF-8 internal string representation to standard
// ASCII bytes for serial connections.
func StringToAsciiBytes(s string) []byte {
	t := make([]byte, utf8.RuneCountInString(s))
	i := 0
	for _, r := range s {
		t[i] = byte(r)
		i++
	}
	return t
}

{{define "printOperand"}}
	v, err = strconv.ParseInt(o.operand{{.}}, 16, 16)
	if err != nil {
		return 0, err
	}

	b = append(b, byte(v))
{{end}}
{{define "handlePrintOperand1"}}
	{{ if eq .RawOperand1 "a8" }} {{ template "printOperand" 1 }}
	{{ else if eq .RawOperand1 "d8" }} {{ template "printOperand" 1 }}
	{{ else if eq .RawOperand1 "a16" }} {{ template "printOperand" 1 }}
	{{ else if eq .RawOperand1 "d16" }} {{ template "printOperand" 1 }}
	{{- end }}
{{end}}
{{define "handlePrintOperand2"}}
	{{ if eq .RawOperand2 "a8" }} {{ template "printOperand" 2 }}
	{{ else if eq .RawOperand2 "d8" }} {{ template "printOperand" 2 }}
	{{ else if eq .RawOperand2 "a16" }} {{ template "printOperand" 2 }}
	{{ else if eq .RawOperand2 "d16" }} {{ template "printOperand" 2 }}
	{{- end }}
{{end}}

{{define "opcodeTypeStruct" }}
{{range $key, $value := .}}
type {{.ExtendedMnemonic}} struct {
	addr string // 0x50
	operand1 string // literal, or reg name, or (HL)...
	operand2 string // same
	isCbPrefixed bool
}

func (o *{{.ExtendedMnemonic}}) Execute(v *vm.VM) {
}

func (o *{{.ExtendedMnemonic}}) Write(w io.Writer) (int, error) {
	var b []byte

	{{ if .CBPrefixed }} 
		b = append(b, 0xCB)
	{{end}}

	b = append(b, {{.Addr}})

	var v int64
	var err error
	_ = v
	_ = err
	{{template "handlePrintOperand1" . }}
	{{template "handlePrintOperand2" . }}

	return w.Write(b)
}

func (o *{{.ExtendedMnemonic}}) String() string {
	return "{{.Mnemonic}} " + o.operand1 {{if .Operand2}} + "," + o.operand2 {{end}}
}
func (o *{{.ExtendedMnemonic}}) SymbolicString() string {
	return "{{.Mnemonic}}{{if .Operand1}} {{.Operand1}}{{end}}{{if .Operand2}},{{.Operand2}}{{end}}"
}
{{end}}
{{end}}

{{template "opcodeTypeStruct" .Unprefixed}}
{{template "opcodeTypeStruct" .CBPrefixed}}

{{define "readOneByte"}}
	s, err = readBytesAsString(data, 1)
	if err != nil {
		return nil, fmt.Errorf("useful error message: %v", err)
	}
{{end}}
{{define "readTwoBytes"}}
	s, err = readBytesAsString(data, 2)
	if err != nil {
		return nil, fmt.Errorf("useful error message: %v", err)
	}
{{end}}
{{define "handleOperand"}}
	{{ if eq . "a8" }} {{ template "readOneByte" . }}
	{{ else if eq . "d8" }} {{ template "readOneByte" . }}
	{{ else if eq . "a16" }} {{ template "readTwoBytes" . }}
	{{ else if eq . "d16" }} {{ template "readTwoBytes" . }}
	{{ else if eq . "(HL)" }} {{ template "readTwoBytes" . }}
	{{ else if eq . "(HL-)" }} {{ template "readTwoBytes" . }}
	{{ else if eq . "(HL+)" }} {{ template "readTwoBytes" . }}
	{{ else }} s = "{{ . }}"
	{{- end }}
{{end}}


{{define "readOpCode"}}
	d := make([]byte, 1)
	_, err := data.Read(d)
	if err != nil {
		return nil, err
	}
	switch d[0] {
	{{ range $key, $value := .}}
	case {{$value.Addr}}: // {{$value.Addr}} - {{$value.Mnemonic}}
		{{- if eq $value.Mnemonic "PREFIX"}} 
			return read{{$value.RawOperand1}}PrefixedOpcode(data)
		{{- else}}
			o := &{{$value.ExtendedMnemonic}}{}

			var s string
			{{- template "handleOperand" .RawOperand1 -}}
			o.operand1 = s
			{{- template "handleOperand" .RawOperand2 -}}
			o.operand2 = s

			return o, nil
		{{end}}
	{{ end }}

	default:
		return nil, fmt.Errorf("the proposed opcode (dec %d, hex %x) doesn't exist: %v", d[0], d[0], ErrNoOpCode)
	}
{{ end }}

// ReadOpCode returns an executable opcode by taking an io.Reader
// and reading a single instruction off it. If there is no more data
// returns undelying io.Reader's EOF error type.
func ReadOpCode(data io.Reader) (OpCode, error) {
{{template "readOpCode" .Unprefixed}}
}

func readCBPrefixedOpcode(data io.Reader) (OpCode, error) {
{{template "readOpCode" .CBPrefixed}}
}