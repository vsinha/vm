package opcodes

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
)

// ErrNoOpCode is a little alias for the error message returned below
var ErrNoOpCode = errors.New("no opcode with that address exists")

// TODO this has problems because many of the opcodes have the same mnemonic,
// so we have to think about how to disambiguate them or if we even want to
type Op int

{{define "write8BitOperand"}}
	err = binary.Write(w, endianness, o.operand{{.}}.(int8))
	if err != nil {
		return written, err
	}
	written += 1
{{end}}
{{define "write16BitOperand"}}
	err = binary.Write(w, endianness, o.operand{{.}}.(int16))
	if err != nil {
		return written, err
	}
	written += 2
{{end}}

{{define "handleWriteByteOperand1"}}
	{{ if eq .RawOperand1 "a8" }} {{ template "write8BitOperand" 1 }}
	{{ else if eq .RawOperand1 "(a8)" }} {{ template "write8BitOperand" 1 }}
	{{ else if eq .RawOperand1 "d8" }} {{ template "write8BitOperand" 1 }}
	{{ else if eq .RawOperand1 "a16" }} {{ template "write16BitOperand" 1 }}
	{{ else if eq .RawOperand1 "(a16)" }} {{ template "write16BitOperand" 1 }}
	{{ else if eq .RawOperand1 "d16" }} {{ template "write16BitOperand" 1 }}
	{{- end }}
{{end}}
{{define "handleWriteByteOperand2"}}
	{{ if eq .RawOperand2 "a8" }} {{ template "write8BitOperand" 2 }}
	{{ else if eq .RawOperand2 "(a8)" }} {{ template "write8BitOperand" 2 }}
	{{ else if eq .RawOperand2 "d8" }} {{ template "write8BitOperand" 2 }}
	{{ else if eq .RawOperand2 "a16" }} {{ template "write16BitOperand" 2 }}
	{{ else if eq .RawOperand2 "(a16)" }} {{ template "write16BitOperand" 2 }}
	{{ else if eq .RawOperand2 "d16" }} {{ template "write16BitOperand" 2 }}
	{{ else if eq .RawOperand2 "SP+r8" }} {{ template "write8BitOperand" 2 }}
	{{- end }}
{{end}}

{{define "opcodeTypeStruct" }}
{{range $key, $value := .}}
type {{.ExtendedMnemonic}} struct {
	addr string // {{ .Addr }}
	operand1 interface{} // literal, or reg name, or (HL)...
	operand2 interface{} // same
	isCbPrefixed bool
}

func (o *{{.ExtendedMnemonic}}) Write(w io.Writer) (int, error) { // {{.Addr}}
	var b []byte

	b = append(b, {{.Addr}})

	var v int64
	_ = v // suppress unused variable warning in the case we have no operands 

	written, err := w.Write([]byte{ 
		{{ if .CBPrefixed }} 0xCB, {{end}}
		{{.Addr}},
	})
	if err != nil {
		return written, err
	}

	{{template "handleWriteByteOperand1" . }}
	{{template "handleWriteByteOperand2" . }}

	return written, err
}

func (o *{{.ExtendedMnemonic}}) Length() uint8 { // {{.Addr}}
	return {{.Length}} 
}

func (o *{{.ExtendedMnemonic}}) cycles() []uint8 { // {{.Addr}}
	return []uint8{ {{ range $key, $value := .Cycles }} {{$value}}, {{end}} }
}

func (o *{{.ExtendedMnemonic}}) String() string { // {{.Addr}}
	{{if eq .Operand2 "SP+r8"}}
	return fmt.Sprintf("{{.Mnemonic}} %v SP+%d", o.operand1, o.operand2)
	{{else if .Operand2}}
	return fmt.Sprintf("{{.Mnemonic}} %v %v", o.operand1, o.operand2)
	{{else}}
	return fmt.Sprintf("{{.Mnemonic}} %v", o.operand1)
	{{end}}
}
func (o *{{.ExtendedMnemonic}}) SymbolicString() string { // {{.Addr}}
	return "{{.Mnemonic}}{{if .Operand1}} {{.RawOperand1}}{{end}}{{if .Operand2}},{{.RawOperand2}}{{end}}"
}

{{end}}
{{end}}

{{template "opcodeTypeStruct" .Unprefixed}}
{{template "opcodeTypeStruct" .CBPrefixed}}

{{define "readOneByte"}}
	s, err = readBytesAsString(data, 1)
	if err != nil {
		return nil, fmt.Errorf("useful error message: %v", err)
	}
{{end}}
{{define "readTwoBytes"}}
	s, err = readBytesAsString(data, 2)
	if err != nil {
		return nil, fmt.Errorf("useful error message: %v", err)
	}
{{end}}
{{define "handleOperand"}}
	{{ if eq . "(a8)" }}       s, err := readImmediate8BitAddress   (data)
	{{ else if eq . "d8" }}    s, err := readImmediate8BitData      (data)
	{{ else if eq . "r8" }}    s, err := readImmediateSigned8BitData(data)
	{{ else if eq . "SP+r8" }} s, err := readImmediateSigned8BitData(data)
	{{ else if eq . "a16" }}   s, err := readImmediate16BitAddress  (data)
	{{ else if eq . "(a16)" }} s, err := readImmediate16BitAddress  (data)
	{{ else if eq . "d16" }}   s, err := readImmediate16BitData     (data)
	{{ else if eq . "(HL)" }}  s, err := readImmediate16BitData     (data)
	{{ else if eq . "(HL-)" }} s, err := readImmediate16BitData     (data)
	{{ else if eq . "(HL+)" }} s, err := readImmediate16BitData     (data)
	{{ else }}                 s      := "{{ . }}"
	{{- end }}
{{end}}


{{define "readInstruction"}}
	d := make([]byte, 1)
	_, err := data.Read(d)
	if err != nil {
		return nil, err
	}
	switch d[0] {
	{{ range $key, $value := .}}
	case {{$value.Addr}}: // {{$value.Addr}} - {{$value.Mnemonic}}
		{{- if eq $value.Mnemonic "PREFIX"}} 
			return read{{$value.RawOperand1}}PrefixedInstruction(data)
		{{- else}}
			o := &{{$value.ExtendedMnemonic}}{}

			{
				{{- template "handleOperand" .RawOperand1 -}}
				if err != nil {
					return nil, err
				}
				o.operand1 = s
			}
			{
				{{- template "handleOperand" .RawOperand2 -}}
				if err != nil {
					return nil, err
				}
				o.operand2 = s
			}

			return o, nil
		{{end}}
	{{ end }}

	default:
		return nil, fmt.Errorf("the proposed opcode (dec %d, hex %x) doesn't exist: %v", d[0], d[0], ErrNoOpCode)
	}
{{ end }}

// ReadOpCode returns an executable opcode by taking an io.Reader
// and reading a single instruction off it. If there is no more data
// returns undelying io.Reader's EOF error type.
func ReadInstruction(data io.Reader) (Instruction, error) {
{{template "readInstruction" .Unprefixed}}
}

func readCBPrefixedInstruction(data io.Reader) (Instruction, error) {
{{template "readInstruction" .CBPrefixed}}
}